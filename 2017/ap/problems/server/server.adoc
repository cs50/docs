---
layout: default
---
:skip-front-matter:

= Problem: Server

Questions? Feel free to head to https://www.reddit.com/r/cs50[CS50 on Reddit], http://cs50.stackexchange.com[CS50 on StackExchange], the `#cs50ap` channel on https://cs50x.slack.com[CS50x Slack] (after signing up), or the https://www.facebook.com/groups/cs50[CS50 Facebook group].

== tl;dr

Implement a web server's request handling functionality.

include::../../honesty.adoc[]

== Assessment

Your work on this problem set will be evaluated along four axes primarily.

Scope::
 To what extent does your code implement the features required by our specification?
Correctness::
 To what extent is your code consistent with our specifications and free of bugs?
Design::
 To what extent is your code written well (i.e., clearly, efficiently, elegantly, and/or logically)?
Style::
 To what extent is your code readable (i.e., commented and indented with variables aptly named)?

To obtain a passing grade in this course, all students must ordinarily submit all assigned problems unless granted an exception in writing by the instructor.

== Getting Ready

First, join David for a tour of HTTP, the “protocol” via which web browsers and web servers communicate.

video::hU4XuBe50K4?rel=0[youtube]

Next, consider reviewing some of these examples, via which we introduced HTML, the language in which web pages are written.

video::1TgTA4o_AM8?rel=0&amp;playlist=dW4giTKrgzo,GgpyVgkW_xk,whYnf7PFZ74,s1_kxTs5GfI,qyJXI2v7N8k,DQLbgo7Rzpg[youtube]

And also some of these examples, via which we introduced CSS, the language with which web pages can be stylized.

video::TKZlfZDF8Y4?rel=0&amp;playlist=VwCSw2ts388,-7wiXVMh4XY[youtube]

Next, consider reviewing some of these examples, via which we introduced HTML forms, which we used to submit GET queries to Google.

video::RQ2_TIXBo00?rel=0&amp;playlist=14jiSM4CMtY,uqsKEAAvpTA,P7oACLRGnEg,AI2nKW7_pck[youtube]

For another perspective altogether, join Daven for a tour of HTML too. Don’t miss the bloopers at the end!

video::dM5V1epAbSs?rel=0[youtube]

Finally, join Joseph (and Rob) for a closer look at CSS.

video::kg0ZOmUREwc?rel=0[youtube]

== Getting Started

First, log into cs50.io and execute

[source,bash]
----
update50
----

within a terminal window to make sure your workspace is up-to-date.

Then execute

[source,bash]
----
cd ~/workspace/chapterB
----

at your prompt to ensure that you’re inside of `chapterB` (which is inside of `workspace` which is inside of your home directory). Then execute

[source,bash]
----
wget http://docs.cs50.net/2017/ap/problems/server/server.zip
----

to download this problem’s distro. Unzip the ZIP file (remember how?) and then delete the ZIP file from your `chapterB` directory. Navigate into your newly-created `server` directory (remember how?) and type:

[source,bash]
----
ls
----

You should see that your directory contains five files and a folder.

[source,bash,subs=quotes]
----
Makefile	parser.c	parser.h	pointers.c	[blue]#public#/		server.o
----

Now execute

[source,bash]
----
tree
----

(which is a hierarchical, recursive variant of `ls`), and you should see that the directory contains the below.

[source,bash]
----
.
├── Makefile
├── parser.c
├── parser.h
├── pointers.c
├── public
│   ├── cat.html
│   ├── cat.jpg
│   ├── favicon.ico
│   ├── hello.html
│   ├── hello.php
│   └── test
│       └── index.html
└── server.o
----

Dang it, still C. But some other stuff too!

Go ahead and take a look at `cat.html`. Pretty simple, right? Looks like it has an `img` tag, the value of whose `src` attribute is `cat.jpg`.

Next, take a look at `hello.html`. Notice how it has a `form` that’s configured to submit via GET a `text` field called `name` to `hello.php`. Make sense? If not, try taking another look at the https://youtu.be/RQ2_TIXBo00[walkthrough for `search-0.html`].footnote:[We no longer cover PHP in CS50 AP, so not to worry if this piece of code seems rather cryptic. Suffice it to say that knowledge of PHP isn't necessary in order to complete the problem! If interested, however, do take a look at resources available from previous iterations of the course!]

Now take a look at `hello.php`. Notice how it’s mostly HTML but inside its `body` is a bit of PHP code:

[source,php]
----
<?= htmlspecialchars($_GET[“name”]) ?>
----

The `<?=` notation just means “echo the following value here”. `htmlspecialchars`, meanwhile, is just an atrociously named function whose purpose in life is to ensure that special (even dangerous!) characters like `<` are properly “escaped” as HTML “entities”. See http://php.net/manual/en/function.htmlspecialchars.php for more details if curious. Anyhow `$_GET` is a “superglobal” variable inside of which are any HTTP parameters that were passed via GET to `hello.php`. More specifically, it’s an “associative array” (i.e., hash table) with keys and values. Per that HTML form in `hello.html`, one such key should be `name`! But more on all that in a bit.

Now the fun part. Open up `parser.h` and `parser.c`.

The challenge ahead is to implement the parsing part of a web server that knows how to serve static content (i.e., files ending in `.html`, `.jpg`, et al.) and dynamic content (i.e., files ending in `.php`).

Want to try out the staff’s solution before we dive into distribution code? Execute the below to download the latest version of the staff’s solution, as the version in CS50 IDE by default is outdated. Note that the `O` in `-O` is a capitalized letter `O`, not a zero.

[source,bash]
----
sudo wget –O ~cs50/chapterB/server http://docs.cs50.net/2016/ap/problems/server/server
sudo chmod a+x ~cs50/chapterB/server
----

Then execute the below to run the staff’s implementation of `server`.

[source,bash]
----
~cs50/chapterB/server
----

You should see these instructions:

[source,bash]
----
Usage: server [-p port] /path/to/root
----

Looks a bit complex, but that’s just a conventional way of saying:

* This program’s name is `server`.
* To specify a (TCP) port number on which `server` should listen for HTTP requests, include `-p` as a command-line argument, followed by (presumably) a number. The brackets imply that specifying a port is optional. (If you don’t specify, the program will default to port 8080, which is required by CS50 IDE.)
* The last command-line argument to `server` should be the path to your server’s “root” (the directory from which files will be served).

Let’s try it out. Execute the below within your own `~/workspace/chapterB` directory so that the staff’s solution uses your own copy of `public` as its root.

[source,bash]
----
~cs50/chapterB/server public
----

You should see output like the below.

[source,bash,subs=quotes]
----
[yellow]#Using /home/Ubuntu/workspace/chapterB/public for server’s root#
[yellow]#Listening on port 8080#
----

Toward the top-right corner of CS50 IDE, meanwhile, you should see your workspace’s “fully qualified domain name,” an address of the form `ide50-username.cs50.io`, where `username` is your own username. Visit `https://ide50-username.cs50.io/` (where `username` is your own username) in another tab. You should see a “directory listing” (i.e. an unordered list) of everything that’s in `public`, yes? And if you click *cat.jpg*, you should see a happy cat. If not, do just reach out to classmates or staff for a hand!

Incidentally, even though `server` is running on port 8080, CS50-IDE’s is “port-forwarding” port 80 (which, recall, is browsers’ default) to 8080 for you. That’s why you don’t need to specify 8080 in the URL you just visited.

Anyhow, assuming you indeed saw a happy cat in that tab, you should also see

[source,bash]
----
GET /cat.jpg HTTP/1.1
----

in your terminal window, which is the “request line” that your browser sent to the server (which is being outputted by `server` via `printf` for diagnostics’ sake). Below that you should see all of the headers that your browser sent to `server` followed by

[source,bash,subs=quotes]
----
[green]#HTTP/1.1 200 OK#
----

which is the server’s response to the browser (which is also being outputted by `server` via `printf` for diagnostics’ sake).

Next, just like I did in that short on HTTP, open up Chrome’s developer tools, per the instructions at https://developer.chrome.com/devtools. Then, once open, click the tools’ *Network* tab, and then, while holding down Shift, reload the page.

Not only should you see Happy Cat again, you should also see the below in your terminal window.

[source,bash,subs=quotes]
----
GET /cat.jpg HTTP/1.1
[green]#HTTP/1.1 200 OK#
----

You might also see the below.

[source,bash,subs=quotes]
----
GET /favicon.ico HTTP/1.1
[green]#HTTP/1.1 200 OK#
----

What’s going on if so? Well, by convention, a lot of websites have in their root directory a `favicon.ico` file, which is just a tiny icon that’s meant to be displayed in a browser’s address bar or tab. If you do see those lines in your terminal window, that just means Chrome is guessing that your server, too , might have `favicon.ico` file, which it does!

Here’s a quick walkthrough if a demo may help.

video::3dmp0ycKC5c?rel=0[youtube]

Alright, now try visiting `https://ide50-username.cs50.io/cat.html`. (Note the `.html` instead of `.jpg` this time.) You should see Happy Cat again, possibly with a bit of margin around him (simply because of Chrome’s default CSS properties). If you look at the developer tools’ *Network* tab (possibly after reloading, if they weren’t still open), you should see that Chrome first requested `cat.html` followed by `cat.jpg`, since the latter, really, was specified as the value of the `img` element’s `src` attribute that we saw earlier in `cat.html`. To confirm as much, take a look at the developer tools’ *Elements* tab, wherein you’ll see a pretty-printed version of the HTML in `cat.html`. You can even change the HTML, but only Chrome’s in-memory copy thereof. To change the actual file, you’d need to do so in the usual way within CS50 IDE. Incidentally, you might find it interesting to tinker with the developer tools’ *Styles* tab, too. Even though this page doesn’t’ have any CSS of its own, you can see and change (temporarily) Chrome’s default CSS properties via that tab.

Okay, one last test. Try visiting `https://ide50-username.cs50.io/hello.html`. Go ahead and input your name into the form and then submit it, as by clicking the button or hitting Enter. You should find yourself at a URL like `https://ide50-username.cs50.io/hello.php?name=Alice` (albeit with your name, not Alice’s, unless your name is also Alice), where a personalized hello awaits! That’s what we mean by “dynamic” content. By submitting that form, you provided input (i.e., your name) to the server, which then generated output just for you. (That input was in the form of an “HTTP parameter” called `name`, the value of which was your name.) Indeed,  if you look at the page’s source code (as via the developer tools’ *Elements* tab), you’ll see your name embedded within the HTML! By contrast, files like `cat.jpg` and `cat.html` (and even `hello.html`) are “static” content, since they’re not dynamically generated.

Neat, eh?? Though odds are you’ll find it easier to test your own code via a command line than with a browser. So let’s show you one other technique.

Open up a second terminal window and position it alongside your first. In the first terminal window, execute

[source,bash]
----
~cs50/chapterB/server public
----

from within your `~/workspace/chapterB` directory, if the server isn’t already running. Then, in the second terminal window, execute the below. (Note the `http://` this time instead of `https://`.)

[source,bash]
----
curl –i http://localhost:8080/
----

If you haven’t used `curl` before, it’s a command-line program with which you can send HTTP requests (and more) to a server in order to see its responses. The `-i` flag tells `curl` to include responses’ HTTP headers in the output. Odds are, whilst debugging your server, you’ll find it more convenient (and revealing!) to see all of that via `curl` than by poking around Chrome’s developer tools.

Incidentally, take care not to request `cat.jpg` (or any binary file) via `curl`, else you’ll see quite a mess! (You’re about to try, aren’t you.)

Unfortunately, your server right now doesn’t have functionality… yet! If you open up `parser.h`, you’ll see declarations and descriptions for six functions, `error`, `extract_request`, `extract_headers`, `parse`, `extract_query`, and `respond`. While implementing your server, do take care to note the follow.

* You may alter `Makefile`
* You may alter `parser.h`, but may not alter the declarations of any of the functions therein. Odds are, you won’t need to change `parser.h`.
* You may alter `parser.c`, and in fact, must in order to complete the implementation of your server.
* Do not delete the `server.o` file as that’s where most of the server’s implementation is held!

Alright, ready to go?

== OmgLikeWhut

Recall that HTTP messages adhere to a “grammar,” which is to say they’re formatted according to a set of rules, patterns that web servers and web browsers can parse. Consider a (simplified) grammar below, wherein any bold symbol is further defined by some other rule. Know that `CRLF` represents `\r\n`, that `SP` represents a single white space, that `*` means “zero or more” (of whatever’s in parentheses), that `/` means “or” and that square brackets mean something’s optional.

[source,bash]
----
HTTP-message	=	*start-line*
			*( *header-field* CRLF )
			CRLF
			[ message-body ]
start-line	=	*request-line* /  *status-line*
request-line	=	method SP *request-target* SP HTTP-version CRLF
status-line	=	HTTP-version SP status-code SP reason-phrase CRLF
header-field	=	field-name “:” field-value
----

One important task of web servers is to parse the HTTP message to ensure the messages are “grammatically correct”.

Before we jump into coding, let’s review a old friend from our past: pointers (you’ll thank us later)! Recall that a `string` is just a `char*`, which is a pointer to single character. The program will then continue reading 1 byte (the size of a `char`) at a time until a `\0` is reached. So if we have the following string:

[source,c]
----
char* word = “hello, world”;
----

Then the `char*` pointer, word, would point to the first letter in the string, which in this case, is `h`. Let’s arbitrarily say that `h` is located in memory at location `0x05` (remember hex?). Then the `e` would be at `0x06`, the `l` at `0x07` and so on and so forth until the NULL terminator is read at `0x11`. So if we had a pointer that pointed to the NULL terminator, and the pointer, word, we can get the length of the string by subtracting the pointer, word, from the pointer that points to the NULL terminator (`0x11 – 0x05 = 0x0C` which is 12, the length of the string word). Remember, _all_ strings end with a NULL terminator, even an empty string such as `””`!

Still confused? Open up `pointers.c` and take a look at the code inside. Here, we parse a sentence, `”hello, world”` to find the first and second words of the sentence. We isolate the variables, once in a char array and once using dynamically allocated memory. Note that `strcpy` copies in the `’\0’` whereas `strncpy` does not. You’re more than welcome, and in fact encouraged, to use `pointers.c` as a reference throughout this problem.

== Divide and Conquer

Feel free to divide the work in whichever manner you believe to be the most efficient, but our recommendation is for one person to take on the `extract_request`, `extract_headers`, and `extract_query`, while the other person tackles `parse`. Be sure to communicate throughout the whole coding and problem-solving process to make the problem much easier! After all, two heads are better than one.

== Such Parsing, Much Wow

If you try to run your version of `server`, you’ll see that it doesn’t do much at all. Now that we had that little review of pointers, your job, as a team, is to implement the parsing functionality. Let’s dive in.

=== extract_request

Complete the implementation of `extract_request` in such a way that the function takes the parameter `message`, which is the HTTP message, and returns the request-line.

The request-line of the message is the part of HTTP message up to and including the first `CRLF` (or `\r\n`). If no `CRLF` is found, respond to the browser with *500 Internal Server Error* by calling

[source,c]
----
error(500);
----

and returning NULL. Else, if a `CRLF` is found, “extract” the request-line by dynamically allocating (remember how?) a `char*` and taking care to copy only the request-line into the new `char*`. Do take care to ensure all your strings end in a NULL terminator and not to worry about freeing your dynamically allocated memory! We take care of that for you in `server.o`.

Odds are you’ll find functions like `strchr`, `strstr`, `strcpy`, `strncpy`, `strncmp`, `strcmp`, and/or `strcasecmp` of help!

=== extract_headers

Complete the implementation of `extract_headers` in such a way that the function takes the parameter `content` and extracts the headers, responding with the interpreter’s content.

Similarly to `extract_request`, the headers are the part up to and including the first `CRLF CRLF` in `content`. If no `CRLF CRLF` is found, `free` `content`, respond to the browser with *500 Internal Server Error*, and stop the function by simply calling `return`.

Else, copy in the header information to a new variable, though this time the variable need not be in dynamically allocated memory since it is not being returned by the function.

Finally, call `respond` with a `200`. If you look at `parser.h`, you’ll see that `respond` takes four arguments, `code`, `headers`, `body`, and `length`, where `code` is your response code to the browser, `headers` are the headers you extracted in the function, `body` is the part of the HTTP message that comes after the headers (after the `CRLF CRLF`), and `length` is the length of the body. Odds are your call to `respond` will look something like

[source,c]
----
respond(200, headers, needle + 4, length – size of headers);
----

where `headers` is the extracted headers and `needle` (we use the variable name needle to represent finding a needle in a haystack, wherein `content` is the haystack here) is a pointer to `CRLF CRLF`. To calculate the length of the body, calculate the size of the headers and subtract that from `length`, which was passed to `extract_headers` as an argument.

Odds are you’ll find functions like `strchr`, `strstr`, `strcpy`, `strncpy`, `strncmp`, `strcmp`, and/or `strcasecmp` of help!

=== extract_query

Complete the implementation of `extract_query` in such a way that the function takes in `target`, the request-target of the HTTP message, and stores the absolute path and query in `abs_path` and `query` respectively.

Per 5.3 of http://tools.ietf.org/html/rfc7230, a `request-target` can take several forms, the only one of which your server needs to support is

[source,bash]
----
absolute-path [ “?” query ]
----

whereby `absolute-path` (which will not contain `?`) might optionally be followed by a `?` followed by a `query`. For example, a `request-target` may look like

[source,bash]
----
/hello.php
/hello.php?
/hello.php?q=Alice
----

where `/hello.php` is the `absolute-path` for all three above, but the only query present in any of the three `request-target`'s above is `q=Alice`. Do take note that the `?` is part of neither the `absolute-path` nor the `query`. The presence of a `?` simply indicates that there may possibly be a `query` that follows afterwards.

Per `target`, the `request-target` passed into `extract_query` as an argument, so that the `absolute-path` is stored at the address in `abs_path` and the `query` is stored at the address in `query`. If that substring is absent (even if a `?` is present), then `query` should be `””`, thereby consuming one byte, whereby `query[0]` is `’\0’`.

For instance, if `request-target` is `/hello.php` or `/hello.php?` then `query` should have a value of `””`. And if `request-target` is `/hello.php?q=Alice`, then `query` should have a value of `q=Alice`.

Odds are you’ll find functions like `strchr`, `strstr`, `strcpy`, `strncpy`, `strncmp`, `strcmp`, and/or `strcasecmp` of help!

=== parse

Complete the implementation of `parse` in such a way that the function parses (i.e. iterates over) `line`, ensuring that the `request-line` is “grammatically correct”.

Per 3.1.1 of http://tools.ietf.org/html/rfc7230, a `request-line` is defined as

[source,bash]
----
method SP request-target SP HTTP-version CRLF
----

wherein `SP` represents a single space (`{sp}`) and `CRLF` represents `\r\n`. None of `method`, `request-target`, and `HTTP-version`, meanwhile, may contain `SP`.

Parse `line` by isolating the `method`, `request-target`, `HTTP-version` and `CRLF` and storing them into separate `char` array variables, so that a variable named `target` would only hold the `request-target`.

Ensure that `request-line` (which is passed into `parse` as `line`) is consistent with the following rules. If is not, respond to the browser with the appropriate response code, by calling the `error` with the response code as shown below.

[source,c]
----
error(400);
----

* If `method` is not `GET`, respond to the browser with *405 Method Not Allowed* and return `false`;
* If `request-target` does not begin with `/`, respond to the browser with *501 Not Implemented* and return `false`;
* If `request-target` contains a `”`, respond to the browser with *400 Bad Request* and return `false`;
* If `HTTP-version` is not `HTTP/1.1`, respond to the browser with *505 HTTP Version Not Supported* and return `false`;
* If there is no `\r\n`, respond to the browser with *414 Request-URI Too Long* and return `false`;
* If there are more or fewer than two `SP`, respond to the browser with *400 Bad Request* and return `false`;
* If anything else in the `request-line` is incorrectly formatted, respond to the browser with *400 Bad Request* and return `false`;
* Else if everything is properly formatted, call `extract_query` and return `true` as per below

[source,c]
----
extract_query(target, abs_path, query);
return true;
----

wherein `target` is the `request-target` you extracted earlier, and `abs_path` and `query` are the arguments passed into `parse`.

Odds are you’ll find functions like `strchr`, `strstr`, `strcpy`, `strncpy`, `strncmp`, `strcmp`, and/or `strcasecmp` of help!

== Extending the Server

Ready for more? Let's get more involved with how the server code actually runs underneath the hood!footnote:[Well, underneath the object file.]

In your terminal window, execute

[source,bash]
----
cd ~/workspace/chapterB
----

Then execute

[source,bash]
----
wget http://docs.cs50.net/ap/2016/ap/problems/server/2/server2.zip
----

Confirm you've downloaded that file, then unzip `server2.zip` (remember how?) and remove the ZIP file (remember how?).

Then navigate into the `server2` directory and list its contents (remember how?) and you should find that the directory contains four files and one folder

[source,bash,subs=quotes]
----
Makefile	parser.c	parser.h	[blue]#public#/		server.c
----

Copy and paste your `parser.c` from `server` into the distro's `parser.c`, and if relevant, also copy in your `parser.h`. Though you are free to alter this Problem's `Makefile` again, do not copy in the previous `Makefile` since this `Makefile` is a bit different!

== Get Servered

The files in [blue]#`public`#/ as well as `parser.c` and `parser.h` should be familiar to you from Problem 6-6. But maybe not so much with `server.c`. In this problem, you will implement the serving side of the server in order to create a complete server! Let's dive into that distribution code, starting with a high-level overview.

video::OnAItxJhS70?rel=0[youtube]

And now a lower-level tour through the code.

=== server.c

Open up `server.c`, if not open already. Let's take a tour.

* Atop the file are a bunch of "feature test macro requirements" that allow us to use certain functions that are declared (conditionally) in the header files further below.
* Defined next are a few constants that specify limits on HTTP requests sizes. We've (arbitrarily) based their values on defaults used by Apache, a popular web server. See http://httpd.apache.org/docs/2.2/mod/core.html if curious.
* Defined next is `BYTES`, a constant that specifies how many bytes we'll eventually be reading into buffers at a time.
* Next are a bunch of header files, including parser.h, followed by a definition of `BYTE`, which we've indeed defined as an 8-bit `char`, followed by a bunch of prototypes.
* Finally, just above `main` are just a few global variables.

==== main

Let's now walk through `main`.

* Atop `main` is an initialization of what appears to be a global variable called `errno`. In fact, `errno` is defined in `errno.h` and is used by quite a few functions to indicate (via an `int`), in cases of error, precisely which error has occurred. See `man errno` for more details.
* Shortly thereafter is a call to `getopt`, which is a function declared in `unistd.h` that makes it easier to parse command-line arguments. See `man 3 getopt` if curious. Notice how we use `getopt` (and some Boolean expressions) to ensure that `server` is used properly.
* Next notice the call to `start` (for which you may have noticed a prototype earlier). More on that later.
* Below that is a declaration of a `struct sigaction` via which we'll listen for `SIGINT` (i.e., control-c), calling `handler` (a function defined by use elsewhere in `server.c`) if heard.
* And then, after declaring some variables, `main` enters an infinite `while` loop.
** Atop that loop, we first free any memory that might have been allocated by a previous iteration of the loop.
** We then check whether we've been "signaled" via control-c to stop the server.
Thereafter, within an `if` statement, is a call to `connected`, a function you will implement so that it returns `true` if a client (e.g., a browser or even `curl`) has connected to the server.
** After that is a call to `extract_request` and `parse` which you've implemented in Problem 6-6.
** Next is a bunch of code that decodes that path (decoding any URL-encoded characters like %20) and "resolves" the path to a local path, figuring out exactly what file was requested on the server itself.
** Below that, we ascertain whether that path leads to a directory or to a file and handle the request accordingly, ultimately calling `list`, `interpret`, or `transfer`.
*** For directories (that don't have an `index.php` or `index.html` file inside them), we call `list` in order to display the directory's contents.
*** For files ending in `.php` (whose "MIME type" is `text/x-php`), we call `interpret`.
*** For other (supported) files, we call `transfer`.

And that's it for `main`! Notice, though, that throughout `main` are a few uses of `continue`, the effect of which is to jump back to the start of that infinite loop. Just before `continue` in some cases, too, is a call to `error` (another function we wrote) with an HTTP status code. Together, those lines allow the server to handle and respond to errors just before returning its attention to new requests.

==== connected

Oh no, seems like we didn't implement this one. Back to this later.

==== error

Spend a bit of time looking through `error`, which is that function via which we respond to browsers with errors (e.g., 404). This function, though perhaps a bit long, should perhaps have some more familiar constructs. (If curious, we're using `log10` simply to figure out how many digits, and thus `char` s, `code` is.)

==== freedir

This function exists simply to facilitate freeing memory that's allocated by a function called `scandir` that we call in `list`.

==== handler

Thankfully, a short one! This function (called whenever a user hits control-c) essentially tells `main` to call `stop` by setting `signaled`, a global variable, to `true`.

==== htmlspecialchars

This function, named identically to that PHP function we saw earlier, escapes characters (e.g., `<` as `<`) that might otherwise "break" an HTML page. We call it from `list`, lest some file or directory we're listing have a "dangerous" character in its name.

==== indexes

Though perhaps a bit confusing, this function checks to see if `index.php` or `index.html` exists in a directory or folder, and if indeed one exists, returns the path to that file so that the server can load the page.

==== interpret

This function enables the server to interpret PHP files. It's a bit cryptic at first glance, but in a nutshell, all we're doing,, upon receiving a request, say, `hello.php`, is executing a line like

[source,php]
----
QUERY_STRING="name=Alice" REDIRECT_STATUS=200 SCRIPT_FILENAME=homeubuntuworkspaceunit6server2publichello.php php-cgi
----

the effect of which is to pass the contents of `hello.php` to PHP's interpreter (i.e., `php-cgi`), with any HTTP parameters supplied via an "environment variable" called `QUERY_STRING`. Via `load` (a function we wrote), we then read the interpreter's output into memory (via `load). And then we respond to the browser with (dynamically generated) output like

[source,html]
----
HTTP/1.1 200 OK
X-Powered-By: PHP/5.5.9-1ubuntu4.12
Content-type: text/html

<!DOCTYPE html>

<html>
	<head>
		<title>hello</title>
	</head>
	<body>
		hello, Alice
	</body>
</html>
----

Even though the PHP code in `hello.php` is pretty-printed, it's output isn't quite as pretty. (Take a look at `hello.php`. Can you deduce why?)

Odds are you're unfamiliar with `open`. That function opens a `pipe` to a process (`php-cgi` in our case), which provides us with a `FILE` pointer via which we can read that process's standard output (as though it were an actual file).

Notice how this function calls `load`, though, in order to read the PHP interpreter's output into memory and the extraction process is done by `extract_headers`, a function you implemented in the previous problem.

==== list

Ah, here's that function that generates a directory listing. Notice how much code it takes to generate HTML using C, thanks to requisite memory management.

==== load

This function loads a file into dynamically allocated memory, storing the address of the loaded file in content (notice how the argument passed into load is `BYTE** content`, a pointer that points to a pointer that points to a BYTE) and stores the length of the loaded file in length.

==== lookup

A simple function that looks up the MIME type of a file and returns the supported extensions (e.g., `text/html`), else returns NULL.

==== reason

This function simply maps HTTP "status codes" (e.g., `200`) to "reason phrases" (e.g., `OK`).

==== redirect

Ah, neat, this function redirects a client to another location (i.e., URL) by sending a status code of `301` plus a `Location` header.

==== request

Ah, this one's a biggie. But worth reading through. When the server receives a request from a client, the server doesn't know in advance how many characters the request will comprise. And so this function iteratively reads bytes form the client, one buffer's worth at a time, calling `realloc` as needed to store the entire message (i.e., request).

Notice this function's use of pointers, dynamic memory allocation, pointer arithmetic, and more. All somewhat familiar by now, but definitely a lot of it all in one place! Do try to understand each and every line, if only for the practice. Ultimately, it keeps reading bytes from the client until it encounters `\r\n\r\n` (aka `CRLF CRLF`), which, according to HTTP's specs, marks the end of a request's headers.

If curious, know that `read` is quite like `read` except that it reads from a "file descriptor" (i.e., an `int`) instead of from a `FILE` pointer (i.e., `FILE*`). See its `man` page for more.

==== respond

It's this function that actually sends to a client an HTTP response, given a status code, heads, a body, and that body's length. For instance, it's this function that sends a response like the below.

[source,html]
----
HTTP/1.1 200 OK
X-Powered-By: PHP/5.5.9-1ubuntu4.12
Content-type: text/html

<!DOCTYPE html>

<html>
	<head>
		<title>hello</title>
	</head>
	<body>
		hello, Alice
	</body>
</html>
----

Know that `printf` is quite like `printf` (or, really `fprintf`) except that the former, like `read`, writes to a "file descriptor" instead of a `FILE*`.

==== create

Hmm, seems like this function isn't fully implemented yet.

==== listener

Darn, another `TODO`. More on that later.

==== start

Here's the function that started it all (pun intended). This function finds the path to the server's root, ensuring it is executable, then calls `create` and `listen` to help start the server.

==== stop

Drat, another one. But at least it's our last!

==== transfer

This function's purpose in life is to transfer a file from the server to a client. Whereas `interpret` handles dynamic content (generated by PHP scripts), `transfer` handles static content (e.g., JPEGs). Notice how this function calls `load` in order to read some file from disk.

==== urldecode

This function, also named after a PHP function, URL-decodes a string, converting special characters like `%20` back to their original values.

== Service Check

Phew. Now that we're done with our tour of the distro code, let's implement the broken parts of the server! Similarly to `parser.c`, this is a collaboration problem, and you may thus divide the work amongst the two of you however you find fit. Our recommendation is for one person to tackle `connect` and `listener` while the other handles `create` and `stop`.

Though this problem may appear to be conceptually challenging, the number of lines of code you will actually write will not be much. If ever struggling, consult your partner for help!

Recall that if you'd like to play with the staff's implementation of server, execute in a terminal window

[source,bash]
----
~cs50/chapterB/server public
----

and if you'd like to test out your server with curl, execute

[source,bash]
----
curl -i http://localhost:8080/
----

=== connect

Complete the implementation of `connect` in such a way that the function checks whether a client has connected to the server.

First, define a client address of type `struct sockaddr_in` and set the address of the client address to 0. Odds are, you'll find the function `memset` of use.

Then, create a variable of type `socklen_t` that holds the length, or size, of the client address variable. Your code should be something reminiscent of

[source,c]
----
size_t length = x;
----

with `size_t` replaced with `socklen_t` and the length of the client address determined by invoking a function reminiscent of a past problem (how do you determine the size of a variable).

Now, assign `cfd`, a global variable, to the return value of `accept`, passing in the appropriate arguments to `accept`. `accept` takes in three arguments: a socket file descriptor (which, if you remember, we've declared as a global), the address of a `sockaddr` variable, the address of the length of address, and an optional fourth argument, which will not be needed in this situation. If curious, take a look at the `man` page for `accept`. Odds are, your line of code will look something like

[source,c]
----
cfd = accept(x, y, z);
----

where `x`, `y`, and `z` are substituted with the appropriate arguments.

Finally, if the value of `cfd` has not change from `-1`, return `false`, else `true`.

=== listener

Complete the implementation of `listener` in such a way that the function listens for a connection and announces the port in use when connected.

Let's first check the `man` page for `listen`. It seems `listen` takes in two arguments a socket file descriptor and a backlog. Let's first call `listen` with our socket file descriptor and `SOMAXCONN` as our backlog. For those curious, `SOMAXCONN` is simply the max limit, defined in `sys/socket.h`, for the number of pending requests the server will take. If the return value of `listen` is `-1`, call `stop` to terminate the server.

Next, let's do something similar to what we did in `connect`. Let's define another `struct sockaddr_in` address without assigning to it any value, then get the length of your new address.

Once more, let's pull up the `man` page for `getsockname`. Looks familiar, eh? Let's call `getsockname` and if the return value is `-1`, call `stop`.

If `stop` isn't invoked, then our `printf` statements will print out to the terminal on which port the user server is listening. But if you look at our second print statement, `-50` is definitely not the right port that we're listening on! So delete that `TODO` and `-50` and replace it with

[source,c]
----
ntohs(addr.sin_port)
----

where `addr` is the name of your variable of type `sockaddr_in` that you declared earlier.

For those curious, `ntohs` is a function that converts a value's byte order from the network byte order to the host's, or client's, byte order. Some machines are "little endian" while others are "big endian", which are just names for the byte ordering a system uses, so it's important for clients and networks to be able to read data regardless of their byte order. For more information on `ntohs`, feel free to use its `man` page. And if curious about little and big endian, do just take a look at https://betterexplained.com/articles/understanding-big-and-little-endian-byte-order[this], but no need to feel obliged!

=== create

Complete the implementation of `create` in such a way that the function creates a server socket.

Let's first take a look at the `man` page for `socket`.

Hmm, it seems that `socket` takes a `domain`, `type`, and `protocol`, as its arguments. Let's call `socket`, using `AF_INET` and `SOCK_STREAM` for the `domain` and `type` and let's leave `protocol` as `0`, since we don't have a specified protocol for the socket. Let's also assign the return value of `socket` to our global socket variable, `sfd`.

If curious, `AF_INET` simply means we'd like TCPIP as our communication domain and `SOCK_STREAM` let's `socket` know that we'd like our socket to provide a sequenced, reliable stream of bytes for our connection.

According to the `man` page of `socket`, `socket` returns `-1` upon failure, so let's check for failure and if indeed `socket` returned `-1`, call `stop` to terminate the server.

Now, let's allow for reuse of address, to avoid any "Address already in use" messages. We can do that by writing the following code.

[source,c]
----
int optval = 1;
setsockopt(x, SOL_SOCKET, SO_REUSEADDR, y, z);
----

where `x`, `y`, and `z` are the socket file descriptor, the address of the optval variable, and the size of the optval variable respectively.

Finally, let's bind a name, or more accurately an address, to the socket. Create a server address variable of type `struct sockaddr_in` and set the address of the server address to 0. Odds are, you'll find the function `memset` of use. Because your server address is of type `struct sockaddr_in`, we can access inside the struct (similar to `RGBTriple` way back when), by using dot notation. If I wanted to access a field inside the struct named `name`, for example, then I can assign the `name` to `"David"` by doing

[source,c]
----
serv_addr.name = "David";
----

if my variable's name were `serv_addr`. Now assign

* The `sin_family` field of your variable to `AF_INET`
* The `sin_port` field to `htons(port)`
* And the `sin_addr.s_addr` field to `htonl(INADDR_ANY)`

For those curious, `htons` and `htonl` are functions that convert a value's byte order from the network byte order to the host's, or client's, byte order. Some machines are "little endian" while others are "big endian", which are just names for the byte ordering a system uses, so it's important for clients and networks to be able to read data regardless of their byte order. For more information on the functions, feel free to use their `man` pages. And if curious about little and big endian, do just take a look at https://betterexplained.com/articles/understanding-big-and-little-endian-byte-order[this], but no need to feel obliged!

Afterwards, let's replace that ugly `/* TODO */ false` inside the `if` statement with a real Boolean expression. We've created a name for the socket but have yet to assign the name to the socket, so let's do that now.

Check out the `man` page for `bind`. Seems like `bind` takes three arguments. A socket file descriptor (hmm, sounds like something we've already seen in this function), an address (or pointer) to a `sockaddr_in`, and the length, or size, of the address. Upon failure, `bind` returns `-1` so let's change our `if` statement to check if `bind` fails. Your expression should look something like

[source,c]
----
if (bind(x, y, z) == -1)
----

where `x`, `y`, and `z` are replaced by the appropriate arguments. If finding yourself in a pickle, consult your partner and/or `connect` and `listen` for inspiration!

=== stop

Complete the implementation of `stop` in such a way that the function frees any allocated memory not freed and closes any file descriptors still open.

Here's how.

* Check to see if the global variable, `root`, is `NULL`. If not, then call `free`.
* Then check to see if server socket (now, which global variable is that) is open. If still open, call `close` on the server socket.
* Finally, stop the server by calling the `exit` function and passing in `errsv` as its argument.

This was Server.
